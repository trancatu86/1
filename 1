import numpy as np
import pandas as pd
import os
import plotly.graph_objects as go
import plotly.express as px
from functools import partial
from collections import namedtuple
import h5py
import csv

Oct3Band = namedtuple("Oct3Band", ["mean", "lower", "upper"])
oct3bands = (Oct3Band(1.25, 1.12, 1.41), Oct3Band(1.60, 1.41, 1.78), Oct3Band(2.00, 1.78, 2.24),
             Oct3Band(2.50, 2.24, 2.82), Oct3Band(3.15, 2.82, 3.55), Oct3Band(4.00, 3.55, 4.47),
             Oct3Band(5.00, 4.47, 5.62), Oct3Band(6.30, 5.62, 7.08), Oct3Band(8.00, 7.08, 8.91),
             Oct3Band(10.0, 8.91, 11.2), Oct3Band(12.5, 11.2, 14.1), Oct3Band(16.0, 14.1, 17.8),
             Oct3Band(20.0, 17.8, 22.4), Oct3Band(25.0, 22.4, 28.2), Oct3Band(31.5, 28.2, 35.5),
             Oct3Band(40.0, 35.5, 44.7), Oct3Band(50.0, 44.7, 56.2), Oct3Band(63.0, 56.2, 70.8),
             Oct3Band(80.0, 70.8, 89.1), Oct3Band(100., 89.1, 112.), Oct3Band(125., 112., 141.),
             Oct3Band(160., 141., 178.), Oct3Band(200., 178., 224.), Oct3Band(250., 224., 282.),
             Oct3Band(315., 282., 355.), Oct3Band(400., 355., 447.), Oct3Band(500., 447., 562.),
             Oct3Band(630., 562., 708.), Oct3Band(800., 708., 891.), Oct3Band(1000., 891., 1120.),
             Oct3Band(1250., 1120., 1410.), Oct3Band(1600., 1410., 1780.), Oct3Band(2000., 1780., 2240.),
             Oct3Band(2500., 2240., 2820.), Oct3Band(3150., 2820., 3550.), Oct3Band(4000., 3550., 4470.),
             Oct3Band(5000., 4470., 5620.), Oct3Band(6300., 5620., 7080.), Oct3Band(8000., 7080., 8910.),
             Oct3Band(10000., 8910., 11200.), Oct3Band(12500., 11200., 14100.), Oct3Band(16000., 14100., 17800.),
             Oct3Band(20000., 17800., 22400.))


class SynthesisOptions:
  def __init__(self, database=None, no_cross=False, compute_contrib=False, use_mount_stiffness=True, use_direct_avl=False):
    self.no_cross = no_cross
    self.compute_contrib = compute_contrib
    self.use_mount_stiffness = use_mount_stiffness
    self.ftab_default = np.array([[200, 200, 145], [65, 95, 240], [490, 190, 100]])
    self.rpm = None
    self.use_direct_avl = use_direct_avl
    self.database = "./db/database.h5" if database is None else database
    self.num_mounts = self.get_num_mounts()
    self.num_dofs = 6
    self.ref_level = None
    self.to_db = True
    self.a_weight = False
    self.to_3rd_oct = False
    self.to_waterfall = False
    self.response_id = None
    self.response_dbname = None
    self.response_labels = None
    self.target_resp_label = None
    self.force_axis_labels = ("fx", "fy", "fz", "mx", "my", "mz")
    self.accel_axis_labels = ("ax", "ay", "az", "rx", "ry", "rz")
    self.plot_row_height = 400
    self.plot_spacing = 0.1
    self.plot_gap = 20
    if no_cross:
      self.compute_contrib = False

    self.full_model_result = None # "../data/new_cabin_4mounts/0_full/full_1002.csv" # None
    self.avl_mount_factors = None
    self.engine_mount_factors = None
    self.body_mount_factors = None
    self.body_target_factors = None
    self.mount_factors = None
    self.set_tf_factors("avl_mount")
    self.set_tf_factors("engine_mount")
    self.set_tf_factors("body_mount")
    self.set_tf_factors("body_target")
    self.set_tf_factors("mount")

  def set_tf_factors(self, tftype="engine_mount", tf_factors=None):
    if tftype not in ("engine_mount", "body_mount", "body_target", "avl_mount", "mount"):
      raise ValueError("Unsupported tftype. Try with 'avl_mount', 'engine_mount', 'body_mount', 'body_target', or 'mount'")
    
    if tf_factors is None:
      tf_factors = {}

    factors = []
    if tftype != "avl_mount" and tftype != "body_target": 
      for i in range(self.num_mounts):
        factors.append([])
        for j in range(self.num_mounts if tftype != "mount" else 3):
          factors[-1].append(tf_factors.get(f"H-{i+1}-{j+1}", 1.0))
    else:
      for i in range(self.num_mounts):
        factors.append(tf_factors.get(f"H-{i+1}", 1.0))
      
    setattr(self, tftype + "_factors", np.array(factors))
    return

  def get_num_mounts(self):
    if not os.path.exists(self.database):
      return 3
    with h5py.File(self.database, "r") as db:
      if "num_mounts" not in db.attrs:
        return 3
      else:
        return db.attrs["num_mounts"].item()


def build_transformation_matrix(rx, ry, rz):
  rx_rad = np.radians(rx)
  ry_rad = np.radians(ry)
  rz_rad = np.radians(rz)

  transform_rx = np.array([[1,       0,               0       ],
                           [0, np.cos(rx_rad), -np.sin(rx_rad)],
                           [0, np.sin(rx_rad),  np.cos(rx_rad)]])

  transform_ry = np.array([[ np.cos(ry_rad), 0, np.sin(ry_rad)],
                           [      0,         1,       0       ],
                           [-np.sin(ry_rad), 0, np.cos(ry_rad)]])

  transform_rz = np.array([[np.cos(rz_rad), -np.sin(rz_rad), 0],
                           [np.sin(rz_rad),  np.cos(rz_rad), 0],
                           [      0,               0,        1]])

  transform = transform_rz @ transform_ry @ transform_rx
  return transform


def vector_to_csv(vector, freq, opts, vtype="force"):
  full_mat_size = vector.shape[2]
  vector = vector.squeeze(0)
  print(vector.shape, freq.shape)
  vector = np.concatenate([freq[:, None], np.real(vector[:, :, 0]), np.imag(vector[:, :, 0])], axis=1)
  new_idxs = [(i + 1, full_mat_size + i + 1) for i in range(full_mat_size)]
  new_idxs = [0] + [i for pair in new_idxs for i in pair]
  vector = vector[:, new_idxs]
  axes = ("fx", "fy", "fz", "mx", "my", "mz") if vtype=="force" else ("ax", "ay", "az", "rx", "ry", "rz")
  columns = ( ["freq"] + [f"m{idx + 1}.{axis}.{comp}" for idx in range(opts.num_mounts)
                          for axis in axes for comp in ("Re", "Im")] )
  return pd.DataFrame(data=vector, columns=columns)


def get_response_db_n_labels(opts: SynthesisOptions):
  pressure_labels = ("px",)
  accel_labels = ("ax", "ay", "az" ) # , "rx", "ry", "rz")
  
  if not os.path.exists(opts.database):
    return None, None, pressure_labels
      
  with h5py.File(opts.database, "r") as db:
    db_response_ids = {"response_id_aco": [],
                       "response_id_eng": [],
                       "response_id_body": []}
      
    for keyname in db_response_ids.keys():
      attr_name = "response_id" if keyname == "response_id_aco" else keyname
      if attr_name in db.attrs:
        if isinstance(db.attrs[attr_name], np.int64) and db.attrs[attr_name].size == 1:
          db_response_ids[keyname] = [db.attrs[attr_name].item()]
        elif isinstance(db.attrs[attr_name], np.ndarray):
          db_response_ids[keyname] = db.attrs[attr_name].tolist()
    print("opts.response_id")  
    print(opts.response_id)  
    
    if opts.response_id is None:
      response_id = (db_response_ids["response_id_aco"] + db_response_ids["response_id_eng"] + db_response_ids["response_id_body"])[0]
    else:
      response_id = opts.response_id

    if response_id in db_response_ids["response_id_aco"]:
      response_dbname, response_labels = "BodyMount", pressure_labels
    elif response_id in db_response_ids["response_id_body"]:
      response_dbname, response_labels = "BodyMount", accel_labels
    elif response_id in db_response_ids["response_id_eng"]:
      response_dbname, response_labels = "EngMount", accel_labels
    else:
      raise RuntimeError("The response node id does not exist")
    return response_id, response_dbname, response_labels


class Synthesizer(object):
  def __init__(self, opts: SynthesisOptions):
    self._opts = opts
    self._db = None
    self._open_database()
    self.freq_ubound = None

  def _open_database(self):
    self._db = h5py.File(self._opts.database, "r")
    print("database opened")

  def __del__(self):
    if self._db is not None:
      self._db.close()
      print("database closed")

  def _read_groundtrue_result(self, response_id, target_label):
    if self._opts.full_model_result is None:
      return None

    fdata = pd.read_csv(self._opts.full_model_result)
    real_col = f"{response_id}.{target_label}.R"
    imag_col = f"{response_id}.{target_label}.I"
    Atrue = (fdata[real_col] + 1.j * fdata[imag_col]).to_numpy()[:, None]
    return Atrue

  def _read_freq_omega(self, nid):
    """
    read the discrete frequencies and angular vel. (omega) in the database
    """
    eng_dname = f"/EngMount/N{nid}/FX"
    sample = self._db[eng_dname]
    freq = sample["freq"][:]
    omega = 2 * np.pi * freq
    return freq, omega

  def get_flexible_mount_idxs(self):
    if "mount_param_type" not in self._db.attrs:
      mount_param_type = "kelvin-voigt"
    else:
      mount_param_type = self._db.attrs["mount_param_type"]

    if mount_param_type == "kelvin-voigt":
      flexible_idxs = [idx for idx in range(self._opts.num_mounts)]
      return flexible_idxs

    avl_nids = self._db["/NODE_IDS"]["avl_nids"][:].tolist()

    flexible_idxs = []
    for idx, nid in enumerate(avl_nids):
      group_name = f"/MountParams/n{nid}"
      group = self._db[group_name]
      if group.attrs["mount_type"] == "flexible":
        flexible_idxs.append(idx)
    return flexible_idxs

  def calc_freq_ubound(self, eng_nid, body_nid):
    rpm_list = list(self._db["/AVLMount"].keys())
    rpm_list.sort(key=lambda s: int(s[:-3]))
    print('list', rpm_list)
    
    eng_dname = f"/EngMount/N{eng_nid}/FX"
    freq_ubound = np.max(self._db[eng_dname]['freq'])

    for rpm in rpm_list:
      print('rpm', rpm)
      avl_dname = f"/AVLMount/{rpm}"
      freq_ubound = min(freq_ubound, np.max(self._db[avl_dname]['freq']))
  
    body_dname = f"/BodyMount/N{body_nid}/FX"
    freq_ubound = min(freq_ubound, np.max(self._db[body_dname]['freq']))
    self.freq_ubound = freq_ubound
    return

  def get_fixed_flexible_mount_idxs(self):    
    mount_param_type = self._db.attrs.get("mount_param_type", "kelvin-voigt")

    if mount_param_type == "kelvin-voigt":
      fixed_flexible_idxs = [idx for idx in range(self._opts.num_mounts)]
      return fixed_flexible_idxs

    avl_nids = self._db["/NODE_IDS"]["avl_nids"][:].tolist()

    fixed_flexible_idxs = []
    for idx, nid in enumerate(avl_nids):
      group_name = f"/MountParams/n{nid}"
      group = self._db[group_name]
      if group.attrs["mount_type"] == "flexible":
        if group.attrs.get("fixed_in_excite", True):          
          fixed_flexible_idxs.append(idx)
    return fixed_flexible_idxs

  def _build_transformation_matrix(self):
    """
    build transformation matrix from avl csys to body csys (due to the mounting angles)
    """
    full_mat_size = self._opts.num_mounts * self._opts.num_dofs
    transform_mat = np.zeros((full_mat_size, full_mat_size), dtype=float)
    engine_angles = self._db.attrs["engine_angles"]
    _transform = build_transformation_matrix(*engine_angles)
    for idx in range(0, full_mat_size, 3):
      transform_mat[idx:idx+3, idx:idx+3] = _transform
    return transform_mat

  def _build_engine_mount_dynstiff_matrix(self, avl_nids, omega, flex_matrix_idxs, use_factors=False):
    """
    build the dynamic stiffness matrix of the engine mounts

    Args:
        mount_dname (str): the dataset name containing the mount stiffness in the database
        omega (np.ndarray): 2 * pi * f, discrete angular velocities in frequency response analysis.
    """
    nsteps = len(omega)
    full_mat_size = self._opts.num_mounts * self._opts.num_dofs
    mount_axis_labels = ("kx", "ky", "kz")
    Kmm = np.zeros((full_mat_size, full_mat_size), dtype=np.complex128)

    if "mount_param_type" not in self._db.attrs:
      mount_param_type = "kelvin-voigt"
    else:
      mount_param_type = self._db.attrs["mount_param_type"]

    if mount_param_type == "kelvin-voigt":    
      np.fill_diagonal(Kmm, 1e-6)
      Kmm = np.tile(Kmm, (nsteps, 1, 1))
      dset_name = f"/MOUNT_PARAMS"
      mount_dset = self._db[dset_name]
      mount_factors = self._opts.mount_factors
      for idx, mid in enumerate(avl_nids):
        offset_row = idx * self._opts.num_dofs
        offset_col = idx * self._opts.num_dofs
        sls_elem = ( (mount_dset[f"{mid}.sls.c1"][0] * mount_dset[f"{mid}.sls.c2"][0]) /
                     (mount_dset[f"{mid}.sls.c1"][0] + mount_dset[f"{mid}.sls.c2"][0]) )
        if use_factors:
          for target_axis, axis_label in enumerate(mount_axis_labels):
            Kmm[:, target_axis + offset_row, target_axis + offset_col] = mount_factors[idx, target_axis] * (sls_elem + mount_dset[f"{mid}.ftab.{axis_label}"][0])
        else:
          for target_axis, axis_label in enumerate(mount_axis_labels):
            Kmm[:, target_axis + offset_row, target_axis + offset_col] = sls_elem + mount_dset[f"{mid}.ftab.{axis_label}"][0]

      Kmm = np.where( omega[:, None, None] == 0, 0, Kmm/(-np.maximum(omega[:, None, None], 0.1)**2) )
      return Kmm

    # flexible mount dyn. stiff. matrix
    freq = omega / 2 / np.pi
    Kmm = np.tile(Kmm, (nsteps, 1, 1))
    Kmm[:, flex_matrix_idxs, flex_matrix_idxs] = 1e-6
    mount_axis_labels = ("TX", "TY", "TZ", "RX", "RY", "RZ")
    mount_factors = self._opts.mount_factors
    for mount_idx, nid in enumerate(avl_nids):
      offset_row = mount_idx * self._opts.num_dofs
      offset_col = mount_idx * self._opts.num_dofs
      group_name = f"/MountParams/n{nid}/"
      group = self._db[group_name]
      mount_type = group.attrs["mount_type"]
      matrix_type = group.attrs.get("matrix_type", "none")
      if mount_type == "rigid":
        continue
      
      for target_axis, target_axis_label in enumerate(mount_axis_labels):
        for source_axis, src_axis_label in enumerate(mount_axis_labels):
          dset_name = f"{target_axis_label}-{src_axis_label}"
          if matrix_type == "symmetric" and target_axis > source_axis:
            dset_name = f"{src_axis_label}-{target_axis_label}"
          if dset_name not in group:
            continue
          dset = group[dset_name.upper()]
          dyn_stiff = (dset["real"] + 1.j * dset["imag"])

          if use_factors and target_axis < 3 and target_axis == source_axis: # only consider factors for diagonal translational stiffness terms
            interp_dyn_stiff = mount_factors[mount_idx, target_axis] * np.interp(freq, dset["freq"], dyn_stiff)
          else:
            interp_dyn_stiff = np.interp(freq, dset["freq"], dyn_stiff)
          Kmm[:, target_axis + offset_row, source_axis + offset_col] = interp_dyn_stiff
  
    Kmm = np.where( omega[:, None, None] == 0, 0, Kmm/(-np.maximum(omega[:, None, None], 0.1)**2) )
    return Kmm

  def _build_pp_mount_inertance(self, eng_nids, freq):
    ############################################
    # engine-side mount driving point
    ############################################
    nsteps = len(freq)
    full_mat_size = self._opts.num_mounts * self._opts.num_dofs
    Hmm_en = np.zeros((nsteps, full_mat_size, full_mat_size), dtype=np.complex128)
    for target_midx in range(self._opts.num_mounts):
      offset_row = target_midx * self._opts.num_dofs
      for target_axis in range(self._opts.num_dofs):
        target_label = self._opts.accel_axis_labels[target_axis]
        target_mount_id = eng_nids[target_midx]
        for source_midx in range(self._opts.num_mounts):
          if self._opts.no_cross and source_midx != target_midx:
            continue  # ignore the cross transfer functions
          offset_col = source_midx * self._opts.num_dofs
          for source_axis in range(self._opts.num_dofs):
            source_label = self._opts.force_axis_labels[source_axis]
            eng_dname = f"/EngMount/N{eng_nids[source_midx]}/{source_label.upper()}"
            eng_dset = self._db[eng_dname]
            real_col = f"{target_mount_id}.{target_label}.R"
            imag_col = f"{target_mount_id}.{target_label}.I"
            Hmm_en[:, target_axis + offset_row, source_axis + offset_col] = (
              self._opts.engine_mount_factors[target_midx, source_midx]
              * np.interp(freq,
                          eng_dset['freq'][:],
                          eng_dset[real_col] + 1.j * eng_dset[imag_col]
                )
              )
    return Hmm_en

  def _build_body_mount_inertance(self, body_nids, freq):
    ############################################
    # body-side mount driving point
    ############################################
    nsteps = len(freq)
    full_mat_size = self._opts.num_mounts * self._opts.num_dofs
    Hmm_body = np.zeros((nsteps, full_mat_size, full_mat_size), dtype=np.complex128)
    for target_midx in range(self._opts.num_mounts):
      offset_row = target_midx * self._opts.num_dofs
      for target_axis in range(self._opts.num_dofs):
        target_label = self._opts.accel_axis_labels[target_axis]
        target_mount_id = body_nids[target_midx]
        for source_midx in range(self._opts.num_mounts):
          if self._opts.no_cross and source_midx != target_midx:
            continue  # ignore the cross transfer functions
          offset_col = source_midx * self._opts.num_dofs
          for source_axis in range(self._opts.num_dofs):
            source_label = self._opts.force_axis_labels[source_axis]
            body_dname = eng_dname = f"/BodyMount/N{body_nids[source_midx]}/{source_label.upper()}"
            body_dset = self._db[body_dname]
            real_col = f"{target_mount_id}.{target_label}.R"
            imag_col = f"{target_mount_id}.{target_label}.I"
            Hmm_body[:, target_axis + offset_row, source_axis + offset_col] = (
              self._opts.body_mount_factors[target_midx, source_midx] *
              np.interp(freq,
                        body_dset['freq'][:],
                        body_dset[real_col] + 1.j * body_dset[imag_col]
                        )
              )
    return Hmm_body

  def _build_body_target_compliance(self,
                                    response_id: int,
                                    target_resp_label: str,
                                    source_nids: np.ndarray,
                                    dbname: str,
                                    freq: np.ndarray):
    ############################################
    # body-target transfer function
    ############################################
    nsteps = len(freq)
    full_mat_size = self._opts.num_mounts * self._opts.num_dofs
    Hbb = np.zeros((nsteps, self._opts.num_mounts, full_mat_size), dtype=np.complex128)
    for source_midx in range(self._opts.num_mounts):
      offset_col = source_midx * self._opts.num_dofs
      offset_row = source_midx
      for source_axis in range(self._opts.num_dofs):
        source_label = self._opts.force_axis_labels[source_axis]
        response_dname = f"/{dbname}/N{source_nids[source_midx]}/{source_label.upper()}"
        body_dset = self._db[response_dname]
        real_col = f"{response_id}.{target_resp_label}.R"
        imag_col = f"{response_id}.{target_resp_label}.I"
        Hbb[:, offset_row, source_axis + offset_col] = (
          self._opts.body_target_factors[source_midx]
          * np.interp(freq,
                      body_dset['freq'][:],
                      body_dset[real_col] + 1.j * body_dset[imag_col]
            )
          )
    return Hbb

  def _build_avl_accel_matrix(self, avl_nids, freq):
    ############################################
    # mount acceleration
    ############################################
    # data from avl (mounts are fixed at the body-attaching point)
    nsteps = len(freq)
    full_mat_size = self._opts.num_mounts * self._opts.num_dofs
    if self._opts.rpm is None or self._opts.to_waterfall:
      rpm_list = list(self._db["/AVLMount"].keys())
      rpm_list.sort(key=lambda s: int(s[:-3]))

    if not self._opts.to_waterfall:
      if self._opts.rpm is None:
        rpm_list = [rpm_list[0]]
      else:
        rpm_list = [f"{self._opts.rpm}RPM"]
        
    num_rpm = len(rpm_list)            
    acc_avl = np.zeros((num_rpm, nsteps, full_mat_size, 1), dtype=np.complex128)
    for rpm_idx, rpm in enumerate(rpm_list):
      avl_dname = f"/AVLMount/{rpm}"
      avl_dset = self._db[avl_dname]
      for target_midx in range(self._opts.num_mounts):
        offset_row = target_midx * self._opts.num_dofs
        mount_nid = avl_nids[target_midx]
        for target_axis, target_label in enumerate(self._opts.accel_axis_labels[:3]):  # avl only outputs translation accel.
          real_col = f"{mount_nid}.{target_label}.R"
          imag_col = f"{mount_nid}.{target_label}.I"
          acc_avl[rpm_idx, :, target_axis + offset_row, 0] = (
              self._opts.avl_mount_factors[target_midx]
              * np.interp(freq,
                          avl_dset['freq'][:],
                          avl_dset[real_col] + 1.j * avl_dset[imag_col]))
    return acc_avl

  def _transform_avl_accel(self, acc_avl, avl_nids, Hmm_en, transform_mat, omega, fixed_flex_matrix_idxs):
    """
    Transform the acceleration from the avl csys to the car body csys
    
    calculate the acceleration for the mount-free engine model
    
    Note that the acceleration from AVL is calculated with the body-connecting point of the mount springs fixed

    ```text
            acceleration output (acc_avl)
     ________  /
    |        |/
    | Engine |-/\/\/\/\--|#fixed
    |________|
    ```

    However, we should have this point free to do the dynamic substructuring.
    If the option `use_direct_avl` is `True`, it will force using the output acceleration directly for the transformation.

    $
        Transform(acc_avl)
    $

    If the option `use_direct_avl` is `False`, it will calculate the mount-free acceleration first, then transform that acceleration.

    $
        Transform(CalculateMountFreeAccel(acc_avl))
    $

    The mount-free acceleration is decribed as:

    ```text
            acceleration output (CalculateMountFreeAccel(acc_avl))
     ________   /
    |        | /
    | Engine |x          mount springs are removed      x-/\/\/\/\--|#fixed
    |________|
    ```
    
    Args:
        acc_avl (Vector): acceleration output by avl
        avl_nids (List[int]): list of mount-connecting node ids in avl
        Hmm_en (Matrix): inertance matrix of the engine-side mount-connecting points
        transform_mat (Matrix): the transformation matrix
        omega (Array): 2 * pi * f, discrete angular velocities in frequency domain analysis
        mount_dname (str): dataset name containing mount characteristics
        nsteps (int): number of discrete frequencies
        full_mat_size (int): matrix size
    """
    full_mat_size = self._opts.num_mounts * self._opts.num_dofs
    nsteps = len(omega)

    fixed_flex_size = len(fixed_flex_matrix_idxs)    
    if self._opts.use_direct_avl:
      return transform_mat @ acc_avl
    
    Kmm = self._build_engine_mount_dynstiff_matrix(avl_nids, omega, fixed_flex_matrix_idxs, use_factors=False)
    Aem = ( Hmm_en @ (transform_mat @ Kmm @ transform_mat.T) + np.eye(full_mat_size) ) @ (transform_mat @ acc_avl)
    return Aem

  def _calculate_smart(self, Hmm_en, Hmm_body, Kmm, Hbb, Aem, transform_mat, flex_matrix_idxs):
    """
    calculate the transfer function systhesis using SMART

    Args:
        Hmm_en (Matrix): inertance matrix of the engine-side mount-connecting points
        Hmm_body (Matrix): inertance matrix of the body-side mount-connecting points
        Kmm (Matrix): mount dynamic stiffness matrix
        Hbb (Matrix): body mount-connecting points to target transfer function matrix
        Aem (Vector): engine-side mount-connecting points' mount-free acceleration due to working loads (avl)
    """
    H_coupl = Hmm_en + Hmm_body
    flex_size = len(flex_matrix_idxs)
    
    Kmm_transformed = transform_mat @ Kmm @ transform_mat.T
    cols, rows = np.meshgrid(flex_matrix_idxs, flex_matrix_idxs)
    cols, rows = cols.ravel(), rows.ravel()
    inv_flex_Kmm_transformed = np.linalg.pinv(Kmm_transformed[:, rows, cols].reshape(-1, flex_size, flex_size))
    inv_Kmm_transformed = Kmm_transformed
    inv_Kmm_transformed[:, rows, cols] = inv_flex_Kmm_transformed.reshape(-1, flex_size*flex_size)
    H_coupl = H_coupl + inv_Kmm_transformed

    reaction_forces = np.linalg.pinv(H_coupl) @ Aem  # (num_freq_steps, full_mat_size, full_mat_size) @ (num_rpms, num_freq_steps, full_mat_size, 1) = (num_rpms,num_freq_steps, full_mat_size, 1)      
        
        
    #reaction_forces = np.zeros_like(reaction_forces)
    #xaxis, yaxis, zaxis = 0, 1, 2
    #for idx in range(opts.num_mounts):
    #    reaction_forces[:, :, opts.num_dofs * idx + zaxis, :] = 1.0
    
    Asyn = Hbb @ reaction_forces  # (num_freq_steps, num_mounts, full_mat_size) @ (num_rpms, num_freq_steps, full_mat_size, 1) = (num_rpms, num_freq_steps, num_mounts, 1)
    Asyn = Asyn.reshape(Asyn.shape[0], Asyn.shape[1], self._opts.num_mounts, -1)  # (num_rpms, num_freq_steps, num_mounts, num_responses=1)
    return Asyn, reaction_forces

  def _get_flexible_matrix_indices(self, flexible_idxs):
    matrix_idxs = np.array(flexible_idxs, dtype=np.int64) * self._opts.num_dofs
    matrix_idxs = np.repeat(matrix_idxs, self._opts.num_dofs)
    offset = np.arange(self._opts.num_dofs, dtype=np.int64)
    offset = np.tile(offset, len(flexible_idxs))
    return matrix_idxs + offset

  def synthesize(self):
    print("reference level", self._opts.ref_level)
    print("rpm", self._opts.rpm)

    eng_nids = self._db["/NODE_IDS"]["eng_nids"][:].tolist()
    body_nids = self._db["/NODE_IDS"]["body_nids"][:].tolist()
    avl_nids = self._db["/NODE_IDS"]["avl_nids"][:].tolist()

    if self.freq_ubound is None:
      self.calc_freq_ubound(eng_nids[0], body_nids[0])
      print('freq ubound', self.freq_ubound)

    ################################################
    # set some parameter to build assembly matrices
    ################################################
    response_id, response_dbname, target_resp_label = self._opts.response_id, self._opts.response_dbname, self._opts.target_resp_label
    # freq, omega = self._read_freq_omega(eng_nids[0])
    freq = np.arange(self._opts.df, self.freq_ubound, self._opts.df)
    omega = 2 * np.pi * freq

    flexible_idxs = self.get_flexible_mount_idxs()
    flex_matrix_idxs = self._get_flexible_matrix_indices(flexible_idxs)
    
    fixed_flexible_idxs = self.get_fixed_flexible_mount_idxs()
    fixed_flex_matrix_idxs = self._get_flexible_matrix_indices(fixed_flexible_idxs)

    Atrue = self._read_groundtrue_result(response_id, target_resp_label)
    ################################################
    # build matrices
    ################################################
    transform_mat = self._build_transformation_matrix()
    Kmm = self._build_engine_mount_dynstiff_matrix(avl_nids, omega, flex_matrix_idxs, use_factors=True)
    Hmm_en = self._build_pp_mount_inertance(eng_nids, freq)
    Hmm_body = self._build_body_mount_inertance(body_nids, freq)
    source_nids = body_nids if response_dbname == "BodyMount" else eng_nids
    Hbb = self._build_body_target_compliance(response_id, target_resp_label, source_nids,
                                             response_dbname, freq)
    acc_avl = self._build_avl_accel_matrix(avl_nids, freq)
    Aem = self._transform_avl_accel(acc_avl, avl_nids, Hmm_en, transform_mat, omega, fixed_flex_matrix_idxs)
    ##########################################
    # SMART
    ##########################################
    if Hmm_en.shape[-1] == 18:
      print("Rotational dofs are used")
    elif Hmm_en.shape[-1] == 9:
      print("Rotational dofs are not used")
    Asyn, reaction_forces = self._calculate_smart(Hmm_en, Hmm_body, Kmm, Hbb, Aem, transform_mat, flex_matrix_idxs)
    
#    print("Asyn_634")
#    print(Asyn) 

        
    if not self._opts.compute_contrib and not self._opts.no_cross:
      Asyn = np.sum(Asyn, axis=2)  # (num_rpms, num_freq_steps, num_responses=1)

    if not self._opts.to_waterfall:
      Asyn = Asyn.squeeze(0)  # (num_freq_steps, num_mounts, num_responses=1)
    
    return Asyn, Atrue, reaction_forces, Aem, freq


class SynthesisUtility(Synthesizer):

  def __init__(self, opts: SynthesisOptions):
    super().__init__(opts)
    self._data = {"vals": [], "colnames": []}

  def _build_transformer(self, freq):
    transforms = TransformSequence()

    
    if self._opts.a_weight:
      transforms.append(AWeighting(freq))

    if self._opts.to_db:
      transforms.append(DecibelTransform(xref=self._opts.ref_level))
    if self._opts.to_3rd_oct:
      oct3rd_transform = ThirdOctaveTransform(freq, isdecibel=self._opts.to_db)
      xvals = oct3rd_transform.x_ticks
      transforms.append(oct3rd_transform)

    else:
      xvals = freq
  
    return transforms, xvals

  def _add_line_to_data(self, xvals, yvals, line_name, transform=None, add_xvals_col=False, **kwargs):
    if transform is not None:
      yvals = transform(yvals)
       

    iscomplex = np.iscomplexobj(yvals)
    get_mag = lambda x: np.abs(x) if iscomplex else x
    get_phase = partial(np.angle, deg=True)

    if add_xvals_col:
      self._data["vals"].append(xvals)
      self._data["colnames"].append("freq")

    mag_suffix = "mag" if iscomplex else "dB"
    self._data["vals"].append(get_mag(yvals))
    self._data["colnames"].append(line_name + "." + mag_suffix)
    
    if iscomplex:
      self._data["vals"].append(get_phase(yvals))
      self._data["colnames"].append(line_name + ".phase")
    return

  def _add_line_to_data_rate_conversion(self, xvals, yvals, line_name, transform=None,  add_xvals_col=False, **kwargs):       
    if transform is not None:
      yvals = transform(yvals)
       

    iscomplex = np.iscomplexobj(yvals)
    get_mag = lambda x: np.abs(x) if iscomplex else x
    get_phase = partial(np.angle, deg=True)

    if add_xvals_col:
      self._data["vals"].append(xvals)
      self._data["colnames"].append("freq")

    mag_suffix = "mag" if iscomplex else "dB"
    value_convertion = 10**(get_mag(yvals)/10)

    return value_convertion

  def _add_line_to_data_rate_show(self, xvals, yvals, line_name, transform=None, add_xvals_col=False, **kwargs):
    iscomplex = np.iscomplexobj(yvals)
    get_mag = lambda x: np.abs(x) if iscomplex else x
    get_phase = partial(np.angle, deg=True)

    if add_xvals_col:
      self._data["vals"].append(xvals)
      self._data["colnames"].append("freq")

    mag_suffix = "mag" if iscomplex else "dB"
    self._data["vals"].append(get_mag(yvals))
    self._data["colnames"].append(line_name + "." + mag_suffix)
    return      
    
  def get_rpm_list(self):
    rpm_list = [int(rpm[:-3]) for rpm in self._db["/AVLMount"].keys()]
    rpm_list.sort()
    return rpm_list

  def _add_rpm_synthesis_to_data(self, xvals, Asyn, rpm=None, history_label=None, add_xvals_col=False, transform=None, **kwargs):
    target_label = self._opts.target_resp_label
    if self._opts.no_cross or self._opts.compute_contrib:  # single mount or TPA (3-component results) = (freq_steps, num_mounts, 1)
      total_line = np.squeeze(np.sum(Asyn, axis=1), axis=-1)
      if history_label is None:
        line_name = f"{self._opts.target_resp_label}.Total"
      else:
        line_name = f"{history_label}.Total"

      self._add_line_to_data(xvals, total_line, line_name, transform=transform,
                         add_xvals_col=add_xvals_col, **kwargs)  # plot the total line first
      for midx in range(self._opts.num_mounts):  # then plot the line of each mount
        mount_line = Asyn[:, midx, 0]
        legend_name = f"{target_label}.OnlyMnt" if self._opts.no_cross else f"{target_label}.ContribMount"
        if history_label is None:
          line_name = f"{legend_name}{midx + 1}"
        else:
          line_name = f"{history_label}.{legend_name}{midx + 1}"
        self._add_line_to_data(xvals, mount_line, line_name, transform=transform, add_xvals_col=False, **kwargs)
      
      if self._opts.to_db and not self._opts.a_weight and not self._opts.to_3rd_oct:     
          total_array =[]
          for midx in range(self._opts.num_mounts):  # then plot the line of each mount
    #        mount_line_rate = 10**(Asyn[:, midx, 0]/10)
            mount_line_rate = Asyn[:, midx, 0]        
           
            legend_name = f"{target_label}.OnlyMnt" if self._opts.no_cross else f"{target_label}.ContribMount"
            if history_label is None:
              line_name = f"{legend_name}{midx + 1}"
            else:
              line_name = f"{history_label}.{legend_name}{midx + 1}"
            value_conversion = self._add_line_to_data_rate_conversion(xvals, mount_line_rate, line_name, transform=transform, add_xvals_col=False, **kwargs)      
     #       add vào array
            total_array.append(value_conversion)
            print("value_conversion")
            print(value_conversion)
            
          print("total_array")
          print(total_array)        
          sum_array = np.sum(total_array, axis=0)
          rate_array = total_array / sum_array  # phép chia mảng theo phần tử
          print("sum_array")
          print(sum_array)  
          print("rate_array")
          print(rate_array)  
          
          for midx in range(self._opts.num_mounts):  # then plot the line of each mount
            mount_line = rate_array[midx, :]
            legend_name = f"{target_label}.OnlyMntRate" if self._opts.no_cross else f"{target_label}.ContribMountRate"
            if history_label is None:
              line_name = f"{legend_name}{midx + 1}"
            else:
              line_name = f"{history_label}.{legend_name}{midx + 1}"
            self._add_line_to_data_rate_show(xvals, mount_line, line_name, transform=transform, add_xvals_col=False, **kwargs)
        
      
    else:
      line_name = target_label if history_label is None else f"{history_label}.{target_label}"
      if rpm is not None:
        line_name = f"{rpm}rpm.{line_name}"
      self._add_line_to_data(xvals, Asyn[:, 0], line_name, transform=transform,
                             add_xvals_col=add_xvals_col, **kwargs)
    return

  def _add_synthesis_to_data(self, xvals, Asyn, history_label=None, add_xvals_col=False, transform=None, **kwargs):
    num_rpm = 0
    if self._opts.to_waterfall:
      rpm_list = self.get_rpm_list()
      num_rpm = len(rpm_list)
    if num_rpm == 0:
      self._add_rpm_synthesis_to_data(xvals, Asyn, rpm=None, history_label=history_label, add_xvals_col=add_xvals_col, transform=transform, **kwargs)
      return
    for rpmidx, rpm in enumerate(rpm_list):
      xvals_col = add_xvals_col if rpmidx == 0 else False
      self._add_rpm_synthesis_to_data(xvals, Asyn[rpmidx], rpm=rpm, history_label=history_label, add_xvals_col=xvals_col, transform=transform, **kwargs)

  def _add_synthesis_history_to_data(self, xvals, history_data, transform=None, add_xvals_col=False, **kwargs):
    for history_idx, Asyn_data in enumerate(history_data):
      self._add_synthesis_to_data(xvals, Asyn_data.data, history_label=Asyn_data.name, transform=transform,
                                  add_xvals_col=add_xvals_col, **kwargs)
    return

  def _collect_data(self, history_data=None):
    Asyn, _, _, _, freq = self.synthesize()
    transform, xvals = self._build_transformer(freq)
    self._add_synthesis_to_data(xvals, Asyn, add_xvals_col=True, transform=transform)
    if history_data is not None:
      self._add_synthesis_history_to_data(xvals, history_data, transform=transform)

  def to_dataframe(self, history_data=None):
    self._collect_data(history_data)
    pdata = pd.DataFrame(data=np.vstack(self._data["vals"]).T, columns=self._data["colnames"])
    return pdata

  def _preset_waterfall(self):
    self._opts.to_waterfall = True
    self._opts.no_cross = False
    self._opts.compute_contrib = False
    self._opts.to_db = True
    self._opts.to_3rd_oct = False
    return

  def generate_plt_data(self):
    rpm_list = self.get_rpm_list()
    response_nid = self._opts.response_id
    self._preset_waterfall()
    self._collect_data()
    
    output = []
    output.append("BEGIN LOADCASE_INDEX")
    for idx, rpm in enumerate(rpm_list):
      output.append(f"  {rpm}   {idx}")
    output.append("END LOADCASE_INDEX")
    output.append("BEGIN OUTPUT_FRF")
    output.append("BEGIN TITLE")
    output.append("waterfall data exported by the transfer function synthesis")
    output.append("END TITLE")
    output.append(f"BEGIN POINT {response_nid}")
    output.append("/* NFreq   NLdCase   NRes   Code of fp*/")
    pos_of_len_indicator = len(output)
    output.append("")  # placeholder
    output.append("/* Freq   LoadCase   Fluid_P */")
    counter = 0
    data = self._data["vals"]
    freq = data[0]
    for freqidx, fq in enumerate(freq):
      if fq == 0:
        continue
      counter += 1
      for rpm_idx, rpm in enumerate(rpm_list):
        output.append(f"{fq:.5e}   {rpm}   {data[rpm_idx + 1][freqidx]:.8e}")
    output.append(f"END POINT {response_nid}")
    output.append("END OUTPUT_FRF")
    output[pos_of_len_indicator] = (f"{counter}   {len(rpm_list)}   1   1")
    return "\n".join(output)

  def generate_csv_waterfall_data(self):
    rpm_list = self.get_rpm_list()
    response_nid = self._opts.response_id
    self._preset_waterfall()
    self._collect_data()

    output = []
    output.append(",".join(["freq"] + [f"{rpm}" for rpm in rpm_list]))
    data = self._data["vals"]
    freq = data[0]
    for freqidx, fq in enumerate(freq):
      if fq == 0:
        continue
      output.append(",".join(
          [f"{fq:.5e}"] + [f"{data[rpm_idx + 1][freqidx]:.8e}"for rpm_idx in range(len(rpm_list))]
          ))
    return "\n".join(output)


def _get_trace_color(line_colors, trace_name, color_id):
  color_pallete = px.colors.qualitative.Dark24
  if trace_name not in line_colors:
    trace_color = color_pallete[color_id]
    line_colors[trace_name] = trace_color
    color_id += 1
  trace_color = line_colors[trace_name]
  return trace_color, color_id


class ResultTransform(object):
  """abstract class for result transform"""
  def __init__(self):
    pass

  def __call__(self, x, *args, **kwargs):
    raise NotImplementedError()


class Identity(ResultTransform):
  def __call__(self, x, *args, **kwargs):
    return x


class AWeighting(ResultTransform):
  def a_weight_func(x):
    return (12194**2 * x**4) / ( (x**2 + 20.6**2) * np.sqrt( (x**2 + 107.7**2)*(x**2 + 737.9**2) ) * (x**2 + 12194**2) )

  def __init__(self, freq):
    super().__init__()
    a_weight_freq = AWeighting.a_weight_func(freq)
    a_weight_1000 = AWeighting.a_weight_func(1000)
    self._a_weight_pressure = a_weight_freq / a_weight_1000
    self._a_weight_decibel = 20 * np.log10(self._a_weight_pressure)

  def __call__(self, x, *args, isdecibel=False, **kwargs):
    if isdecibel:
      return x + self._a_weight_pressure
    return x * self._a_weight_pressure


class ThirdOctaveTransform(ResultTransform):
  def __init__(self, freq, isdecibel=True):
    super().__init__()
    bins = [oct3.lower for oct3 in oct3bands] + [oct3bands[-1].upper]
    bin_count = len(bins) - 1
    masked_freq = np.ma.masked_less(freq, bins[0])
    bin_indices = np.digitize(masked_freq[~masked_freq.mask], bins)  # an element, x, belongs to bin_i if bins[i-1] <= x < bins[i]
    self.bins = bins
    self.freq = masked_freq
    self._bin_indices = np.minimum(bin_indices - 1, bin_count)
    self._max_index = np.max(self._bin_indices)
    self._isdecibel = isdecibel

  @property
  def x_ticks(self):
    return [getattr(oct3, limit) for oct3 in oct3bands[:self._max_index + 1] for limit in ("lower", "upper")]

  def __call__(self, x, *args, **kwargs):
    # by avl definition: freq_band = [f_lower, f_upper)
    oct3_levels = np.zeros((self._max_index + 1, ))
    mask = ~self.freq.mask
    x = x[mask]
    freq = self.freq.data[mask]
    
    if np.iscomplexobj(x):
      x = np.abs(x)

    if self._isdecibel:
      transform = lambda vals: 10**(vals / 10.)
    else:
      transform = lambda vals: vals**2

    transformed_x = transform(x)
    np.add.at(oct3_levels, self._bin_indices, transformed_x)
    if self._isdecibel:
      oct3_levels = 10*np.log10(oct3_levels)
      oct3_levels = np.nan_to_num(oct3_levels, nan=0, posinf=0, neginf=0)
    else:
      oct3_levels = np.sqrt(oct3_levels)

    oct3_levels = [oct3_levels[idx] for idx in range(self._max_index + 1) for _ in range(2)]
    return oct3_levels


class DecibelTransform(ResultTransform):
  def __init__(self, xref=2e-11, nan=0, posinf=0, neginf=0):
    super().__init__()
    self.xref = xref
    self._nan = 0
    self._posinf = 0
    self._neginf = 0

  def __call__(self, x, *args, **kwargs):
    return np.nan_to_num(20 * np.log10(np.abs(x) / self.xref), nan=self._nan, posinf=self._posinf, neginf=self._neginf)        


class TransformSequence(ResultTransform):
  def __init__(self, *args):
    super().__init__()
    self._transformers = list(args)

  def copy(self):
    copy_transform = TransformSequence(*self._transformers)
    return copy_transform

  def append(self, transform):
    self._transformers.append(transform)

  def __call__(self, x, *args, **kwargs):
    for transform in self._transformers:
      x = transform(x, *args, **kwargs)
    return x


class Plotter:
  def __init__(self, opts: SynthesisOptions):
    self._opts = opts
    self._figure = None
    self._mag_values = []
    self._initialize_plot()
    self._line_colors = {}
    self._color_pallete = px.colors.qualitative.Dark24
    self._color_id = 0
    
  def _initialize_plot(self):
    ncols = nrows = 1
    nsubrows = 2 if not (self._opts.to_db or self._opts.to_3rd_oct) else 1
    self._nsubrows = nsubrows
#    result_name = "Pressure" if len(self._opts.response_labels) <= 1 else "Acceleration"
#    titles = [f"{result_name}.Mag (dB)" if self._opts.to_db else f"{result_name}.Mag", f"{result_name}.Phase"]
    titles =""
    row_heights = []
    for i in range(nrows):
      row_heights.extend([self._opts.plot_row_height] * nsubrows)
      if i < nrows - 1:
        row_heights.append(self._opts.plot_gap)

    # trick: for each row, add one more subrow as the padding space to the next row
    # so, in fact 1 row will be divided into (nsubrow + 1) subrows
    # the last row does not need padding space
    fig = go.Figure(layout={"height": sum(row_heights)}).set_subplots(rows=nrows*(nsubrows + 1) - 1, cols=ncols,
                                                                      subplot_titles=titles,
                                                                      vertical_spacing=self._opts.plot_spacing,
                                                                      row_heights=row_heights)
    self._figure = fig
    return

  @property
  def figure(self):
    return self._figure

  def _get_trace_color(self, trace_name):
    if trace_name not in self._line_colors:
      trace_color = self._color_pallete[self._color_id]
      self._line_colors[trace_name] = trace_color
      self._color_id += 1
    trace_color = self._line_colors[trace_name]
    return trace_color

  def _plot_line(self, xvals, yvals, line_name, line_color, showlegend=True, transform=None, **kwargs):
    """
    Arguments:
        line (Array): an array of complex numbers with shape (num_frequency_steps,)
    """
    if transform is not None:
      yvals = transform(yvals)

    get_mag = lambda x: np.abs(x) if np.iscomplexobj(x) else x
 
    
    
    get_phase = partial(np.angle, deg=True)

    line_format = kwargs.get("line_format", {})

    trace = go.Scatter(
                x=xvals, y=get_mag(yvals),
                name=line_name, legendgroup=line_name, line_color=line_color,
                showlegend=showlegend, **line_format
                )
    self._figure.append_trace(trace, row=1, col=1)

    if np.iscomplexobj(yvals):
      trace = go.Scatter(
                  x=xvals, y=get_phase(yvals),
                  name=line_name, legendgroup=line_name, line_color=line_color,
                  showlegend=False, **line_format
                  )
      self._figure.append_trace(trace, row=2, col=1)
    return

  def _plot_synthesis_result(self, xvals, Asyn, history_name=None, history_idx=None, transform=None, **kwargs):
    line_format = {"opacity": 0.8, "line": dict(dash="dash")} if history_idx is not None else {}
    target_label = self._opts.target_resp_label
        
    
    if self._opts.no_cross or self._opts.compute_contrib:  # single mount or TPA (3-component results) = (freq_steps, num_mounts, 1)
      total_line = np.squeeze(np.sum(Asyn, axis=1), axis=-1)



        
      if history_idx is None:
        line_name = f"{target_label}.Total"
        line_color = "rgb(0, 0, 0)"
      else:
        line_name = f"{history_name}.{target_label}.Total"
        line_color = self._get_trace_color(line_name)

      self._plot_line(xvals, total_line, line_name, line_color, showlegend=True,
                      transform=transform, line_format=line_format, **kwargs)  # plot the total line first
      
      for midx in range(self._opts.num_mounts):  # then plot the line of each mount
        mount_line = Asyn[:, midx, 0]
        legend_name = "OnlyMnt" if self._opts.no_cross else "ContribByMnt"
        if history_idx is None:
          line_name = f"{target_label}.{legend_name}{midx + 1}"
        else:
          line_name = f"{history_name}.{target_label}.{legend_name}{midx + 1}"

        line_color = self._get_trace_color(line_name)
        self._plot_line(xvals, mount_line, line_name, line_color, showlegend=True,
                        transform=transform, line_format=line_format, **kwargs)
    else:
      line_name = target_label if history_idx is None else f"{history_name}.{target_label}"
      line_color = self._get_trace_color(line_name)
      

#      print("Asyn[:, 0]")
#     print(Asyn)  


      self._plot_line(xvals, Asyn[:, 0], line_name, line_color, showlegend=True,
                      transform=transform, line_format=line_format, **kwargs)
    return

  def _plot_synthesis_history(self, xvals, history_data, transform=None, **kwargs):
    for history_idx, Asyn_data in enumerate(history_data):
      self._plot_synthesis_result(xvals, Asyn_data.data, history_name=Asyn_data.name, history_idx=history_idx, transform=transform, **kwargs)
    return

  def _update_layout(self):
    if not self._opts.to_db:
      # FIX BUG: calculate the y tick values and labels for the logscale y-axis
      yaxis_min = float("inf")
      yaxis_max = -float("inf")
      for line in self._figure.data:
        if line.yaxis != "y":
          continue  # phase subplot is ignored
        ydata = np.ma.masked_equal(line.y, 0)  # since log(0) is inf
        miny = ydata.min().item()
        maxy = ydata.max().item()
        yaxis_min = min(yaxis_min, miny)
        yaxis_max = max(yaxis_max, maxy)

      min_log = int(np.log10(yaxis_min)) - 1
      max_log = int(np.log10(yaxis_max)) + 1
      tickvals = []
      ticktexts = []
      for i in range(min_log, max_log + 1):
        tickvals.append(np.arange(1, 10) * 10**i)
        ticktexts.extend([f"{10**i:.0e}"] + [" "] * 8)
      tickvals = np.concatenate(tickvals)
      
      self._figure.update_yaxes(type="log", row=1, col=1,
                                exponentformat="power", dtick="D1", tickmode="array",
                                tickvals=tickvals, ticktext=ticktexts)

    if self._nsubrows == 2:
      self._figure.update_yaxes(dtick=90, row=2, col=1, range=[-200, 200])  # phase subplot

    self._figure.update_xaxes(gridcolor="rgba(157, 157, 157, 0.3)", linecolor="rgba(157, 157, 157, 0.3)",
                              zerolinecolor="rgba(157, 157, 157, 0.3)", matches="x", rangemode="tozero")

    self._figure.update_yaxes(gridcolor="rgba(157, 157, 157, 0.3)", linecolor="rgba(157, 157, 157, 0.3)",
                              zerolinecolor="rgba(157, 157, 157, 0.3)")
    self._figure.update_layout(paper_bgcolor="#fff", plot_bgcolor="#fafafa")
    return

  def _plot_groundtrue(self, xvals, Atrue=None, transform=None, **kwargs):
    if not self._opts.no_cross and not self._opts.compute_contrib:
      line_name = "Reference"
      line_color = "rgb(0, 0, 0)"
      line_format = dict(mode="markers+lines",
                         marker={"symbol": "square", "size": 6, "color": "rgba(0, 0, 255, 0)",
                                 "line": {"width": 1, "color": "rgba(0, 0, 255, 1)"}
                                 })
      self._plot_line(xvals, Atrue[:, 0], line_name, line_color, showlegend=True,
                      transform=transform, line_format=line_format, **kwargs)
    return

  def generate_synthesis_plot_BF(self, freq, Asyn, Atrue=None, history_data=None):
     
#    print("Asyn_1115")
#    print(Asyn)
    
    transforms = TransformSequence()
    if self._opts.a_weight:
      transforms.append(AWeighting(freq))
    if self._opts.to_db:
      transforms.append(DecibelTransform(xref=self._opts.ref_level))
    if self._opts.to_3rd_oct:
      oct3rd_transform = ThirdOctaveTransform(freq, isdecibel=self._opts.to_db)
      xvals = oct3rd_transform.x_ticks
      transforms.append(oct3rd_transform)
    else:
      xvals = freq

    if Atrue is not None:
      self._plot_groundtrue(xvals, Atrue, transform=transforms)

    self._plot_synthesis_result_BF(xvals, Asyn, transform=transforms)

    if history_data is not None:
      self._plot_synthesis_history(xvals, history_data, transform=transforms)

    self._update_layout()
    return self._figure


  def _plot_synthesis_result_BF(self, xvals, Asyn, history_name=None, history_idx=None, transform=None, **kwargs):
      line_format = {"opacity": 0.8, "line": dict(dash="dash")} if history_idx is not None else {}
      target_label = self._opts.target_resp_label
    
      line_name = target_label if history_idx is None else f"{history_name}.{target_label}"
      line_color = self._get_trace_color(line_name)
      


#      self._plot_line(xvals, Asyn, line_name, line_color, showlegend=True,
#                      transform=transform, line_format=line_format, **kwargs)

#      print("get_mag")
#      print(Asyn)

      line_format = kwargs.get("line_format", {})

      trace = go.Scatter(
                x=xvals, y=Asyn,
                name=line_name, legendgroup=line_name, line_color=line_color,
                showlegend=True, **line_format
                )
      self._figure.append_trace(trace, row=1, col=1)

      return
    
  def generate_synthesis_plot(self, freq, Asyn, Atrue=None, history_data=None):
     
#    print("Asyn_1115")
#    print(Asyn)
    
    transforms = TransformSequence()
    if self._opts.a_weight:
      transforms.append(AWeighting(freq))
    if self._opts.to_db:
      transforms.append(DecibelTransform(xref=self._opts.ref_level))
    if self._opts.to_3rd_oct:
      oct3rd_transform = ThirdOctaveTransform(freq, isdecibel=self._opts.to_db)
      xvals = oct3rd_transform.x_ticks
      transforms.append(oct3rd_transform)
    else:
      xvals = freq

    if Atrue is not None:
      self._plot_groundtrue(xvals, Atrue, transform=transforms)

    self._plot_synthesis_result(xvals, Asyn, transform=transforms)

    if history_data is not None:
      self._plot_synthesis_history(xvals, history_data, transform=transforms)

    self._update_layout()
    return self._figure
