import os
import shutil
import numpy as np
from collections import namedtuple
from threading import Timer
import pandas as pd
import datetime


current_path = os.getcwd()

def delete_file_in_folder(base_dir):
    if os.path.isdir(base_dir):
        # Duyệt tất cả file và thư mục con trong folder_path
        for item in os.listdir(base_dir):
            item_path = os.path.join(base_dir, item)
            try:
                if os.path.isfile(item_path) or os.path.islink(item_path):
                    os.remove(item_path)  # Xóa file hoặc link
                elif os.path.isdir(item_path):
                    shutil.rmtree(item_path)  # Xóa thư mục và toàn bộ nội dung bên trong
            except Exception as e:
                print(f"Failed to delete {item_path}. Reason: {e}")


def delete_folder_file(base_dir):
    # Lặp qua từng thư mục con trong base_dir
    for folder_name in os.listdir(base_dir):
        folder_path = os.path.join(base_dir, folder_name)
        if os.path.isdir(folder_path):
            # Duyệt tất cả file và thư mục con trong folder_path
            for item in os.listdir(folder_path):
                item_path = os.path.join(folder_path, item)
                try:
                    if os.path.isfile(item_path) or os.path.islink(item_path):
                        os.remove(item_path)  # Xóa file hoặc link
                    elif os.path.isdir(item_path):
                        shutil.rmtree(item_path)  # Xóa thư mục và toàn bộ nội dung bên trong
                except Exception as e:
                    print(f"Failed to delete {item_path}. Reason: {e}")

def convert_csv_BodyBlockedForce(file_list):
    
    parts =[]
    # Danh sách tên file CSV
    """
    file_list = ['BodyMount_N1000_FX_FY_FZ_MX_MY_MZ.csv', 'BodyMount_N1001_FX_FY_FZ_MX_MY_MZ.csv',
                    'BodyMount_N1002_FX_FY_FZ_MX_MY_MZ.csv', 'BodyMount_N1003_FX_FY_FZ_MX_MY_MZ.csv',
                    'BodyMount_N1004_FX_FY_FZ_MX_MY_MZ.csv']
    """
    # Lấy đường dẫn hiện tại
    current_path = os.getcwd()  

    body_response_nids = []
    body_microphone_response_nids = []
    microphone_response_nids = [] 

    with open(file_list[0], 'r', encoding='utf-8') as f:
      column_line = f.readline().strip()
    column = column_line.split(',')
        
        
    for k in range(1,int(len(column))):     
      
        nid = column[k].split(".")[0]
        wrench = column[k].split(".")[1]
        lbl = column[k].split(".")[2]
        MagPhase = column[k].split(".")[3]
        if wrench =="FX" and lbl == "ax" and MagPhase=="Mag":
            body_response_nids.append(int(nid))
        if wrench =="FX" and lbl == "px" and MagPhase=="Mag":            
            microphone_response_nids.append(int(nid)) 

    rpm=0  
    bodydata = {}
    bodydata_body = {}
    column_names = {}
    column_names_body = {}       

    for file_name in file_list:   
        base_name = os.path.splitext(os.path.basename(file_name))[0]  # 'BodyMount_N1000_FX_FY_FZ_MX_MY_MZ'        
        parts = base_name .split("_")  # tách chuỗi thành danh sách các phần tử  

        FX = parts[1]  + "_"+ parts[2] + ".csv"
        FY = parts[1]  + "_"+ parts[3] + ".csv"
        FZ = parts[1]  + "_"+ parts[4] + ".csv"
        MX = parts[1]  + "_"+ parts[5] + ".csv"
        MY = parts[1]  + "_"+ parts[6] + ".csv"
        MZ = parts[1]  + "_"+ parts[7] + ".csv"
        t=0
        for wrench in [FX,FY,FZ,MX,MY,MZ]:
            k=0    
            data = pd.read_csv(file_name).to_numpy()   
            rpm = 0        
            bodydata[rpm] = []
            column_names[rpm] = []  
            for item_microphone_response in microphone_response_nids:
                body_freq = data[:, 0]
                body_resp_3 = data[:, 12*k+1+2*t]
                body_resp_4 = data[:, 12*k+2+2*t]
                body_resp = body_resp_3 * np.cos(np.radians(body_resp_4)) + 1.j * body_resp_3 * np.sin(np.radians(body_resp_4))
                body_resp_1 = body_resp.real
                body_resp_2 = body_resp.imag        
                k=k+1
                axis = "px"
                new_colnames_1 = [f"{item_microphone_response}.{axis}.{comp}" for comp in ("R", "I")]
                
                if len(bodydata[rpm]):
                    bodydata[rpm].extend([body_resp_1, body_resp_2])
                    column_names[rpm].extend(new_colnames_1)
                else:
                    bodydata[rpm].append([body_freq,body_resp_1,body_resp_2])
                    column_names[rpm].extend(["freq"] + new_colnames_1)
  
            line= 12*k
            bodydata_body[rpm] = []
            column_names_body[rpm] = []    
            k=0            
            for item_body_response in body_response_nids:  
                new_colnames_2= [u + c
                                   for u in [f"{item_body_response}.ax", f"{item_body_response}.ay", f"{item_body_response}.az", f"{item_body_response}.rx", f"{item_body_response}.ry", f"{item_body_response}.rz"]
                                   for c in [".R", ".I"]
                                   ]   
                 
                column_names_body[rpm].extend(new_colnames_2)                
                for i in range(0, 6):
                    body_freq = data[:, 0]
                    body_resp_3 = data[:, line+12*k+1+2*t]
                    body_resp_4 = data[:, line+12*k+2+2*t]
                    
                    body_resp = body_resp_3 * np.cos(np.radians(body_resp_4)) + 1.j * body_resp_3 * np.sin(np.radians(body_resp_4))
                    body_resp_1 = body_resp.real
                    body_resp_2 = body_resp.imag  
                    k=k+1                    
                    bodydata_body[rpm].extend([body_resp_1, body_resp_2])
                    
            bodydata[rpm].extend(bodydata_body[rpm]) 
            column_names[rpm].extend(column_names_body[rpm])            
            for rpm, data in bodydata.items():
                collated_data = pd.DataFrame(np.vstack(data).T, columns=column_names[rpm])
                
            csv_file_path = current_path + "\\BlockedForce\\bf_body_blocked_force_csv_temp\\" +  wrench

            collated_data.to_csv(csv_file_path, index=False)
            t=t+1

def convert_csv_ReactionForce(file_list):
    
    parts =[]
    # Danh sách tên file CSV
    """
    file_list = ['ReactionForce_80001_FX_FY_FZ_MX_MY_MZ.csv', 'ReactionForce_80002_FX_FY_FZ_MX_MY_MZ.csv',
                    'ReactionForce_80003_FX_FY_FZ_MX_MY_MZ.csv']
    FX.Mag	FX.Phase	FY.Mag	FY.Phase	FZ.Mag	FZ.Phase	MX.Mag	MX.Phase	MY.Mag	MY.Phase	MZ.Mag	MZ.Phase

    """
    # Lấy đường dẫn hiện tại
    current_path = os.getcwd()  

    body_response_nids = []
    body_microphone_response_nids = []
    microphone_response_nids = [] 

    with open(file_list[0], 'r', encoding='utf-8') as f:
      column_line = f.readline().strip()
    column = column_line.split(',')
        
    rpm=0  
    bodydata_rf = {}
    bodydata_body = {}
    column_names = {}
    column_names_body = {}       

    for file_name in file_list:   
        base_name = os.path.splitext(os.path.basename(file_name))[0]  # 'BodyMount_N1000_FX_FY_FZ_MX_MY_MZ'        
        parts = base_name .split("_")  # tách chuỗi thành danh sách các phần tử  
        FX = parts[1]  + "_"+ parts[2] + ".csv"
        FY = parts[1]  + "_"+ parts[3] + ".csv"
        FZ = parts[1]  + "_"+ parts[4] + ".csv"
        MX = parts[1]  + "_"+ parts[5] + ".csv"
        MY = parts[1]  + "_"+ parts[6] + ".csv"
        MZ = parts[1]  + "_"+ parts[7] + ".csv"
        t=0
        data = pd.read_csv(file_name).to_numpy()        
        for wrench in [FX,FY,FZ,MX,MY,MZ]:  
            freq = data[:, 0]  # cột tần số
            mag = data[:, 1 + 2 * t]  # cột magnitude
            phase = data[:, 2 + 2 * t]  # cột phase (đơn vị độ)          
            # Tính số phức
            complex_val = mag * np.cos(np.radians(phase)) + 1j * mag * np.sin(np.radians(phase))
            # Tạo dataframe với 2 cột freq và complex
            df_out = pd.DataFrame({
                "freq": freq,
                "complex": complex_val
            })
            # Đường dẫn lưu file CSV
            csv_file_path = current_path + "\\BlockedForce\\bf_reactionforce\\" +  wrench
            # Lưu file CSV
            df_out.to_csv(csv_file_path, index=False)
            t=t+1

def convert_complex(folder_path, output_folder):
    # Tạo thư mục output nếu chưa tồn tại
    os.makedirs(output_folder, exist_ok=True)

    # Duyệt tất cả file trong thư mục
    for filename in os.listdir(folder_path):
        if filename.endswith('.csv'):
            file_path = os.path.join(folder_path, filename)

            # Đọc file CSV
            df = pd.read_csv(file_path)

            # Tìm các cặp cột R và I (đuôi .R và .I)
            # Ví dụ: '2001.px.R' và '2001.px.I'
            # Lấy tên tiền tố chung trước .R hoặc .I
            complex_cols = set()
            for col in df.columns:
                if col.endswith('.R'):
                    prefix = col[:-2]
                    if prefix + '.I' in df.columns:
                        complex_cols.add(prefix)

            # Với mỗi prefix, tạo cột complex = R + I*j, xóa cột R và I cũ
            for prefix in complex_cols:
                real_col = prefix + '.R'
                imag_col = prefix + '.I'
                df[prefix + '_complex'] = df[real_col] + 1j * df[imag_col]
                df.drop(columns=[real_col, imag_col], inplace=True)

            # Lưu file mới với tên 'C.csv' (hoặc bạn có thể đổi tên theo ý muốn)
            output_filename = filename
            output_path = os.path.join(output_folder, output_filename)
            df.to_csv(output_path, index=False)

            
def split_and_group_files(input_folder, output_folder):
    os.makedirs(output_folder, exist_ok=True)

    for filename in os.listdir(input_folder):
        if filename.endswith('.csv'):
            file_path = os.path.join(input_folder, filename)
            # Đọc file CSV
            df = pd.read_csv(file_path)

            # Lấy cột đầu tiên (ví dụ 'freq')
            first_col = df.columns[0]

            # Lặp qua các cột còn lại
            for col in df.columns[1:]:
                df_new = df[[first_col, col]].copy()

                # Loại bỏ '_px_complex' trong tên cột nếu có
                safe_col_name = col.replace('.px_complex', '')

                # Lấy tiền tố nhóm (ví dụ '2001' từ '2001.px_complex')
                # Giả sử tên cột dạng '2001.px_complex' hoặc '2001.px'
                group_name = safe_col_name.split('.')[0]

                # Tạo thư mục nhóm nếu chưa có
                group_folder = os.path.join(output_folder, group_name)
                os.makedirs(group_folder, exist_ok=True)

                new_filename = f"{os.path.splitext(filename)[0]}.csv"
                output_path = os.path.join(group_folder, new_filename)

                # Lưu file mới
                df_new.to_csv(output_path, index=False)

                
def str_to_complex(s):
    try:
        return complex(s)
    except:
        return complex(0,0)  # hoặc xử lý lỗi phù hợp

def multiply_complex_columns(folder_A, folder_B, folder_C):
    os.makedirs(folder_C, exist_ok=True)
    renamefile_reactionforce(folder_A, folder_B)
    # Lấy danh sách file trong folder A và B
    files_A = [f for f in os.listdir(folder_A) if f.endswith('.csv')]
    files_B = [f for f in os.listdir(folder_B) if f.endswith('.csv')]
    
    
    # Tạo dict để dễ tìm file theo tên file (không bao gồm phần mở rộng)
    dict_A = {os.path.splitext(f)[0]: f for f in files_A}
    dict_B = {os.path.splitext(f)[0]: f for f in files_B}
    
#    print("dict_A.keys()")
#    print(dict_A.keys())

#    print("dict_B.keys()")
#    print(dict_B.keys())

    
    # Tìm các file có tên giống nhau (không tính phần mở rộng)
    common_files = set(dict_A.keys()) & set(dict_B.keys())
    common_files = sorted(common_files)
  
#    print("common_files")
#    print(common_files)
    
    
    for base_name in common_files:
        file_A = os.path.join(folder_A, dict_A[base_name])
        file_B = os.path.join(folder_B, dict_B[base_name])

        # Đọc file
        df_A = pd.read_csv(file_A)
        df_B = pd.read_csv(file_B)

        # Lấy cột đầu tiên (cột 1)
        col1 = df_A.columns[0]
        # Lấy cột thứ hai (cột 2) - đã là số phức, nhân trực tiếp
        col2 = df_A.columns[1]
        
        # Chuyển cột số phức (cột 2) sang kiểu complex
        df_A['complex_A'] = df_A.iloc[:,1].apply(str_to_complex)
        df_B['complex_B'] = df_B.iloc[:,1].apply(str_to_complex)

        # Nhân 2 cột số phức
        df_result = pd.DataFrame()
        df_result['freq'] = df_A.iloc[:,0]  # cột freq giữ nguyên
        df_result['complex_product'] = df_A['complex_A'] * df_B['complex_B']

        # Tạo dataframe kết quả
        df_result = pd.DataFrame({
            col1: df_A[col1],
            'complex': df_result['complex_product'] 
        })

        # Lưu file kết quả vào folder C với tên giống file gốc
        output_path = os.path.join(folder_C, base_name + '.csv')
        df_result.to_csv(output_path, index=False)
 


def renamefile_reactionforce(folder_A, folder_B):
    # Lấy danh sách file trong folder A và B
    files_A = [f for f in os.listdir(folder_A) if f.endswith('.csv')]
    files_B = [f for f in os.listdir(folder_B) if f.endswith('.csv')]

    # Tạo dict để dễ tìm file theo tên file (không bao gồm phần mở rộng)
    dict_A = {os.path.splitext(f)[0]: f for f in files_A}
    dict_B = {os.path.splitext(f)[0]: f for f in files_B}
    
#     print("dict_A.keys()")
#     print(dict_A.keys())

#     print("dict_B.keys()")
#     print(dict_B.keys())

    # Lấy keys từ dict_A và dict_B
    keys_A = dict_A.keys()
    keys_B = dict_B.keys()

    # Hàm lấy phần số trước dấu gạch dưới
    def extract_prefix(keys):
        prefixes = set()
        for key in keys:
            prefix = key.split('_', 1)[0]
            prefixes.add(prefix)
        return sorted(prefixes)

    # Lấy dải số từ dict_A và dict_B
    prefixes_A = extract_prefix(keys_A)  # ['80001', '80002', '80003']
    prefixes_B = extract_prefix(keys_B)  # ['1000', '1001', '1002']
    mapping = dict(zip(prefixes_A, prefixes_B))    
    
    files_A = [f for f in os.listdir(folder_A) if f.endswith('.csv')]

    for filename in files_A:
        # Tách phần tên file và phần mở rộng
        name, ext = os.path.splitext(filename)
        # Tách prefix và phần còn lại
        parts = name.split('_', 1)
        if len(parts) == 2:
            prefix, suffix = parts
            # Kiểm tra prefix có trong mapping không
            if prefix in mapping:
                new_prefix = mapping[prefix]
                new_name = f"{new_prefix}_{suffix}{ext}"
                old_path = os.path.join(folder_A, filename)
                new_path = os.path.join(folder_A, new_name)
                # Đổi tên file
                os.rename(old_path, new_path)


 

def sum_complex_columns_in_folder(folder_path, output_folder, output_filename,pres_reflevel,acce_reflevel):

    folder_name = os.path.basename(folder_path)
    print(folder_name)  # Kết quả: MyFolder
    
    try:
        # Thử chuyển folder_name thành số nguyên
        num = int(folder_name)
        os.makedirs(output_folder, exist_ok=True)
        file_list = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
        total_complex = None
        freq = None

        for i, file_name in enumerate(file_list):
            file_path = os.path.join(folder_path, file_name)
            df = pd.read_csv(file_path)

            # Lấy cột freq (cột 1)
            if freq is None:
                freq = df.iloc[:, 0]

            # Lấy cột số phức (cột 2), chuyển sang số phức nếu đang dạng string
            complex_col = df.iloc[:, 1].apply(lambda x: complex(str(x).replace(' ', '')))

            if total_complex is None:
                total_complex = complex_col
            else:
                total_complex = total_complex + complex_col

        magnitude = total_complex.abs()  # hoặc np.abs(total_complex)
        SPL = 20 * np.log10(magnitude / float(pres_reflevel))

        # Công thức A-weighting (đã sửa dấu ngoặc và phép toán)
        numerator = 12194**2 * freq**4
        denominator = (freq**2 + 20.6**2) * np.sqrt((freq**2 + 107.7**2) * (freq**2 + 737.9**2)) * (freq**2 + 12194**2)
        A_weighting = 20 * np.log10(numerator / denominator) + 2

        SPL_A_weight = SPL + A_weighting

        # Tạo dataframe kết quả
        df_result = pd.DataFrame({
            'freq': freq,
            'complex': total_complex,
            'magnitude_MPa': magnitude,         
            'magnitude_dB': SPL,         
            'magnitude_dBA': SPL_A_weight       
        })

        new_filename = f"{output_filename}.csv"
        output_file = os.path.join(output_folder, new_filename)

        # Lưu file kết quả
        df_result.to_csv(output_file, index=False)
    except ValueError:
        os.makedirs(output_folder, exist_ok=True)
        file_list = [f for f in os.listdir(folder_path) if f.endswith('.csv')]
        total_complex = None
        freq = None

        for i, file_name in enumerate(file_list):
            file_path = os.path.join(folder_path, file_name)
            df = pd.read_csv(file_path)

            # Lấy cột freq (cột 1)
            if freq is None:
                freq = df.iloc[:, 0]

            # Lấy cột số phức (cột 2), chuyển sang số phức nếu đang dạng string
            complex_col = df.iloc[:, 1].apply(lambda x: complex(str(x).replace(' ', '')))

            if total_complex is None:
                total_complex = complex_col
            else:
                total_complex = total_complex + complex_col

        magnitude = total_complex.abs()  # hoặc np.abs(total_complex)
        dB = 20 * np.log10(magnitude / float(acce_reflevel))
        
        # Công thức A-weighting (đã sửa dấu ngoặc và phép toán)
        numerator = 12194**2 * freq**4
        denominator = (freq**2 + 20.6**2) * np.sqrt((freq**2 + 107.7**2) * (freq**2 + 737.9**2)) * (freq**2 + 12194**2)
        A_weighting = 20 * np.log10(numerator / denominator) + 2

        acc_A_weight = dB + A_weighting



        # Tạo dataframe kết quả
        df_result = pd.DataFrame({
            'freq': freq,
            'complex': total_complex,
            'magnitude_MPa': magnitude,         
            'magnitude_dB': dB,
            'magnitude_dBA': acc_A_weight               
        })

        new_filename = f"{output_filename}.csv"
        output_file = os.path.join(output_folder, new_filename)

        # Lưu file kết quả
        df_result.to_csv(output_file, index=False)
        
# Định nghĩa các băng tần 1/3 octave
Oct3Band = namedtuple("Oct3Band", ["mean", "lower", "upper"])
oct3bands = (
    Oct3Band(1.25, 1.12, 1.41), Oct3Band(1.60, 1.41, 1.78), Oct3Band(2.00, 1.78, 2.24),
    Oct3Band(2.50, 2.24, 2.82), Oct3Band(3.15, 2.82, 3.55), Oct3Band(4.00, 3.55, 4.47),
    Oct3Band(5.00, 4.47, 5.62), Oct3Band(6.30, 5.62, 7.08), Oct3Band(8.00, 7.08, 8.91),
    Oct3Band(10.0, 8.91, 11.2), Oct3Band(12.5, 11.2, 14.1), Oct3Band(16.0, 14.1, 17.8),
    Oct3Band(20.0, 17.8, 22.4), Oct3Band(25.0, 22.4, 28.2), Oct3Band(31.5, 28.2, 35.5),
    Oct3Band(40.0, 35.5, 44.7), Oct3Band(50.0, 44.7, 56.0), Oct3Band(63.0, 56.0, 70.7),
    Oct3Band(80.0, 70.7, 89.1), Oct3Band(100.0, 89.1, 112.0), Oct3Band(125.0, 112.0, 141.0),
    Oct3Band(160.0, 141.0, 178.0), Oct3Band(200.0, 178.0, 224.0), Oct3Band(250.0, 224.0, 282.0),
    Oct3Band(315.0, 282.0, 355.0), Oct3Band(400.0, 355.0, 447.0), Oct3Band(500.0, 447.0, 562.0),
    Oct3Band(630.0, 562.0, 708.0), Oct3Band(800.0, 708.0, 891.0), Oct3Band(1000.0, 891.0, 1120.0),
    Oct3Band(1250.0, 1120.0, 1410.0), Oct3Band(1600.0, 1410.0, 1780.0), Oct3Band(2000.0, 1780.0, 2240.0),
    Oct3Band(2500.0, 2240.0, 2820.0), Oct3Band(3150.0, 2820.0, 3550.0), Oct3Band(4000.0, 3550.0, 4470.0),
    Oct3Band(5000.0, 4470.0, 5620.0), Oct3Band(6300.0, 5620.0, 7080.0), Oct3Band(8000.0, 7080.0, 8910.0),
    Oct3Band(10000.0, 8910.0, 11200.0), Oct3Band(12500.0, 11200.0, 14100.0), Oct3Band(16000.0, 14100.0, 17800.0),
    Oct3Band(20000.0, 17800.0, 22400.0)
)

class ThirdOctaveTransform:
    def __init__(self, freq, isdecibel=True):
        self.freq = np.ma.masked_less(freq, oct3bands[0].lower)
        bins = [band.lower for band in oct3bands] + [oct3bands[-1].upper]
        self.bins = bins
        self.isdecibel = isdecibel
        self.bin_indices = np.digitize(self.freq.compressed(), bins) - 1
          
        
        
        self.max_index = max(self.bin_indices) if len(self.bin_indices) > 0 else 0

    @property
    def x_ticks(self):
        # Trả về danh sách tick (lower và upper) cho từng băng tần
        ticks = []
        for band in oct3bands[:self.max_index + 1]:
            ticks.append(band.lower)
            ticks.append(band.upper)
        return ticks

    def __call__(self, x, *args, **kwargs):
        # Lọc dữ liệu theo mask
        mask = ~self.freq.mask
     
        x = x[mask]
        freq = self.freq.data[mask]

        if np.iscomplexobj(x):
            x = np.abs(x)

        if self.isdecibel:
            transform = lambda vals: 10 ** (vals / 10.)
        else:
            transform = lambda vals: vals ** 2

        transformed = transform(x)

        # Lọc bin_indices tương ứng với mask
        bin_indices = self.bin_indices[mask]

        levels = np.zeros(self.max_index + 1)
        
#        print(f"len(self.bin_indices) = {len(self.bin_indices)}")
#        print(f"len(mask) = {len(transformed[0])}")
        
        # Đảm bảo transformed và bin_indices có cùng kích thước
        np.add.at(levels, bin_indices, transformed)

        if self.isdecibel:
            levels = 10 * np.log10(levels)
            levels = np.nan_to_num(levels, nan=0, posinf=0, neginf=0)
        else:
            levels = np.sqrt(levels)

        # Lặp lại mỗi giá trị 2 lần cho tick
        levels_expanded = []
        for val in levels:
            levels_expanded.extend([val, val])

        return levels_expanded

def OneThirdOctave_calculation(input_folder,output_folder ):
    for filename in os.listdir(input_folder):
        if filename.endswith('.csv'):
            file_path = os.path.join(input_folder, filename)
            df = pd.read_csv(file_path)

            # Lấy cột 1 từ hàng số 3 trở đi (index 2 trở đi)
            freq = df.iloc[1:, 0].reset_index(drop=True)
 
            
            # Lấy cột 5 từ hàng số 3 trở đi (index 2 trở đi)
            data_dbA = df.iloc[1:, 4].reset_index(drop=True)
            
            if pd.isna(freq.iloc[-1]):
                freq = freq.iloc[:-1]

            if pd.isna(data_dbA.iloc[-1]):
                data_dbA = data_dbA.iloc[:-1]

            freq_array = freq.to_numpy()
            data_array = data_dbA.to_numpy()

            # Khởi tạo biến chuyển đổi
            transform = ThirdOctaveTransform(freq_array, isdecibel=True)

            # Lấy tick cho trục x
            x_ticks = transform.x_ticks

            # Chuyển đổi dữ liệu sang dạng 1/3 octave
            y_values = transform(data_array)



            df_new = pd.DataFrame({
                'freq': x_ticks,
                'value': y_values
            })

            output_path = os.path.join(output_folder, filename)
            df_new.to_csv(output_path, index=False)


def interpolate_complex_csv(input_folder,output_folder, delta_freq,pres_reflevel,acce_reflevel):
    print("interpolate_complex_csv")
   
    for filename in os.listdir(input_folder):
      
        if filename.endswith('.csv'):
            file_path = os.path.join(input_folder, filename)   

            # Đọc dữ liệu
            df = pd.read_csv(file_path)
            # Lấy cột freq và value (giá trị phức)
            value = df['complex'].apply(lambda x: complex(x.replace(' ', ''))).values
            freq = df.iloc[0:, 0].reset_index(drop=True)

            value = df.iloc[0:, 1].reset_index(drop=True)
            value_new = value.apply(lambda x: complex(x.replace(' ', ''))).values
        
            freq_array = freq.to_numpy()            


            # Tạo dải tần số mới theo delta_freq
            freq_new = np.arange(freq_array[0], freq_array[-1], delta_freq)


            # Nội suy phần thực và phần ảo riêng biệt
            real_interp = np.interp(freq_new, freq_array, value_new.real)
            imag_interp = np.interp(freq_new, freq_array, value_new.imag)

            # Kết hợp lại thành số phức
            value_new = real_interp + 1j * imag_interp
            
            magnitude =  np.abs(value_new)  # hoặc np.abs(total_complex)
            file_name_with_ext = os.path.basename(file_path)
            file_name, file_ext = os.path.splitext(file_name_with_ext)

            try:
                # Thử chuyển folder_name thành số nguyên
                num = int(file_name)
        
                SPL = 20 * np.log10(magnitude / float(pres_reflevel))

                # Công thức A-weighting (đã sửa dấu ngoặc và phép toán)
                numerator = 12194**2 * freq_new**4
                denominator = (freq_new**2 + 20.6**2) * np.sqrt((freq_new**2 + 107.7**2) * (freq_new**2 + 737.9**2)) * (freq_new**2 + 12194**2)
                A_weighting = 20 * np.log10(numerator / denominator) + 2

                SPL_A_weight = SPL + A_weighting
                # Tạo dataframe kết quả
                df_new = pd.DataFrame({
                    'freq': freq_new,
                    'SPL_complex': value_new,
                    'SPL_magnitude_MPa': magnitude,         
                    'SPL_magnitude_dB': SPL,         
                    'SPL_magnitude_dBA': SPL_A_weight       
                })
                output_path = os.path.join(output_folder, filename)
                df_new.to_csv(output_path, index=False)

            except ValueError:
                SPL = 20 * np.log10(magnitude / float(acce_reflevel))

                # Công thức A-weighting (đã sửa dấu ngoặc và phép toán)
                numerator = 12194**2 * freq_new**4
                denominator = (freq_new**2 + 20.6**2) * np.sqrt((freq_new**2 + 107.7**2) * (freq_new**2 + 737.9**2)) * (freq_new**2 + 12194**2)
                A_weighting = 20 * np.log10(numerator / denominator) + 2

                SPL_A_weight = SPL + A_weighting

                # Tạo dataframe kết quả
                df_new = pd.DataFrame({
                    'freq': freq_new,
                    'SPL_complex': value_new,
                    'SPL_magnitude_MPa': magnitude,         
                    'SPL_magnitude_dB': SPL,         
                    'SPL_magnitude_dBA': SPL_A_weight       
                })
                output_path = os.path.join(output_folder, filename)
                df_new.to_csv(output_path, index=False)
    




def csv_blockedforce_calculation(pres_reflevel,acce_reflevel):
    input_folder = current_path + '\\BlockedForce\\bf_body_blocked_force_csv_temp'  
    output_folder = current_path + '\\BlockedForce\\body_blocked_force_convert_complex\\'
    convert_complex(input_folder, output_folder)
    
    input_folder = current_path + '\\BlockedForce\\body_blocked_force_convert_complex\\'
    output_folder = current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\' 
    split_and_group_files(input_folder, output_folder)
 

    folder_a = current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\'  # Thư mục gốc
    # Lấy danh sách các thư mục con trong folder_a
    subfolders = [f for f in os.listdir(folder_a) if os.path.isdir(os.path.join(folder_a, f))]

    for folder_name in subfolders:
        folder_reactionforce = current_path + '\\BlockedForce\\bf_reactionforce\\'   
        folder_body = current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\' + folder_name
        output_folder = current_path + '\\BlockedForce\\multiply_complex_columns\\'+ folder_name

        multiply_complex_columns(folder_reactionforce, folder_body, output_folder)    
        input_folder = current_path + '\\BlockedForce\\multiply_complex_columns\\'+ folder_name  
        output_folder = current_path + '\\BlockedForce\\SPL_BF\\'  
        sum_complex_columns_in_folder(input_folder, output_folder, folder_name,pres_reflevel,acce_reflevel)
        
    input_folder = current_path + '\\BlockedForce\\SPL_BF\\'
    output_folder = current_path + '\\BlockedForce\\SPL_BF_3rdOctave\\' 
    OneThirdOctave_calculation(input_folder, output_folder)   
    

   
#    shutil.rmtree(current_path + '\\BlockedForce\\body_blocked_force_convert_complex\\')
#    shutil.rmtree(current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\')
#    shutil.rmtree(current_path + '\\BlockedForce\\multiply_complex_columns\\')        

    
def pch_blockedforce_calculation(pres_reflevel,acce_reflevel):
    
    input_folder = current_path + '\\BlockedForce\\body_blocked_force_convert_complex\\'
    output_folder = current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\' 
    split_and_group_files(input_folder, output_folder)
 

    folder_a = current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\'  # Thư mục gốc
    # Lấy danh sách các thư mục con trong folder_a
    subfolders = [f for f in os.listdir(folder_a) if os.path.isdir(os.path.join(folder_a, f))]

    for folder_name in subfolders:
        folder_reactionforce = current_path + '\\BlockedForce\\bf_reactionforce\\'   
        folder_body = current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\' + folder_name
        output_folder = current_path + '\\BlockedForce\\multiply_complex_columns\\'+ folder_name
        multiply_complex_columns(folder_reactionforce, folder_body, output_folder)    

        input_folder = current_path + '\\BlockedForce\\multiply_complex_columns\\'+ folder_name  
        output_folder = current_path + '\\BlockedForce\\SPL_BF\\'  
        sum_complex_columns_in_folder(input_folder, output_folder, folder_name,pres_reflevel,acce_reflevel)
        
    input_folder = current_path + '\\BlockedForce\\SPL_BF\\'
    output_folder = current_path + '\\BlockedForce\\SPL_BF_3rdOctave\\' 
    OneThirdOctave_calculation(input_folder, output_folder)        
#    shutil.rmtree(current_path + '\\BlockedForce\\body_blocked_force_convert_complex\\')
#    shutil.rmtree(current_path + '\\BlockedForce\\body_blocked_force_split_and_group_files\\')
#    shutil.rmtree(current_path + '\\BlockedForce\\multiply_complex_columns\\')        



 
